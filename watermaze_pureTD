{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from numpy.linalg import norm\n",
    "import random\n",
    "import matplotlib.pyplot as plt\n",
    "from matplotlib import cm\n",
    "import math\n",
    "from matplotlib.patches import Circle\n",
    "import mpl_toolkits.mplot3d.art3d as art3d\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 80,
   "metadata": {},
   "outputs": [],
   "source": [
    "####################################################################################################\n",
    "# watermaze module\n",
    "####################################################################################################\n",
    "class watermaze(object):\n",
    "    \n",
    "    \"\"\"\n",
    "    This class defines a set of functions for simulating a rat moving in a water-maze.\n",
    "    \n",
    "    For the purposes of this assignment, you should be using the move function to \n",
    "    determine the next state of the environment at each time-step of the simulation.\n",
    "    \n",
    "    See the demo of its usage after the module code.\n",
    "    \"\"\"\n",
    "    \n",
    "    ####################################################################\n",
    "    # the initialization function, measurements are in cm\n",
    "    def __init__(self, pool_radius=60, platform_radius=10, platform_location=np.array([25,25]), \n",
    "                 stepsize=5.0, momentum=0.2, T=120):\n",
    "        \n",
    "        \"\"\"\n",
    "        The init function for the watermaze module.\n",
    "        \n",
    "        - The pool_radius argument specifies the radius of the pool.\n",
    "        \n",
    "        - The platform_radius argument specifies the radius of the platform.\n",
    "        \n",
    "        - The platform_location argument specifies the location of the platform centre.\n",
    "        \n",
    "        - The stepsize argument specifies how far the rat moves in one step.\n",
    "        \n",
    "        - The momentum argument specifies the ratio of old movement to new movement direction (i.e. \n",
    "        momentum = 0 means all new movement, momentum = 1 means all old movement, otherwise a mix.\n",
    "        \n",
    "        - The T argument is the maximum time for a trial in the pool.\n",
    "\n",
    "        \n",
    "        \"\"\"\n",
    "        \n",
    "        # store the given info\n",
    "        self.radius            = pool_radius\n",
    "        self.platform_radius   = platform_radius\n",
    "        self.platform_location = platform_location\n",
    "        self.stepsize          = stepsize\n",
    "        self.momentum          = momentum\n",
    "        self.T                 = T\n",
    "        \n",
    "        # a dictionary for calculating directions\n",
    "        self.direction = {\n",
    "            0:  np.pi/2, #north\n",
    "            1:  np.pi/4, #north-east\n",
    "            2:  0, #east\n",
    "            3:  7*np.pi/4, #south-east\n",
    "            4:  3*np.pi/2, #south\n",
    "            5:  5*np.pi/4, #south-west\n",
    "            6:  np.pi, #west\n",
    "            7:  3*np.pi/4, #north-west\n",
    "        }\n",
    "        \n",
    "        # initialize the dynamic variables\n",
    "        self.position = np.zeros((2,T))\n",
    "        self.t        = 0\n",
    "        self.prevdir  = np.zeros((2,))\n",
    "        \n",
    "    ####################################################################\n",
    "    # for updating the rat's position in the pool\n",
    "    def move(self, A):\n",
    "\n",
    "        \"\"\"\n",
    "        Updates the simulated rat's position in the water-maze environment by moving it in the \n",
    "        specified direction. \n",
    "        \n",
    "        - The argument A is the last selected action, and must be an integer from 0-7, with 0 indicating N, \n",
    "        1 indicating NE, etc. \n",
    "\n",
    "        \"\"\"\n",
    "        \n",
    "        # check the A argument\n",
    "        if (not np.isin(A, np.arange(8))):\n",
    "            print('Error: The argument A must be an integer from 0-7, indicating which action was selected.')\n",
    "\n",
    "        # determine the vector of direction of movement\n",
    "        angle = self.direction[A]\n",
    "        newdirection = np.array([np.cos(angle), np.sin(angle)])\n",
    "        \n",
    "        # add in momentum to reflect actual swimming dynamics (and normalize, then multiply by stepsize)\n",
    "        direction = (1.0 - self.momentum)*newdirection + self.momentum*self.prevdir\n",
    "        direction = direction/np.sqrt((direction**2).sum())\n",
    "        direction = direction*self.stepsize\n",
    "        \n",
    "        # update the position, prevent the rat from actually leaving the water-maze by having it \"bounce\" off the wall \n",
    "        [newposition, direction] = self.poolreflect(self.position[:,self.t] + direction)\n",
    "\n",
    "        # if we're now at the very edge of the pool, move us in a little-bit\n",
    "        if (np.linalg.norm(newposition) == self.radius):\n",
    "            newposition = np.multiply(np.divide(newposition,np.linalg.norm(newposition)),(self.radius - 1))\n",
    "\n",
    "        # update the position, time (and previous direction)\n",
    "        self.position[:,self.t+1] = newposition\n",
    "        self.t                    = self.t + 1\n",
    "        self.prevdir              = direction\n",
    "        \n",
    "    ####################################################################\n",
    "    # for bouncing the rat off the wall of the pool\n",
    "    def poolreflect(self, newposition):\n",
    "        \n",
    "        \"\"\"\n",
    "        The poolreflect function returns the point in space at which the rat will be located if it \n",
    "        tries to move from the current position to newposition but bumps off the wall of the pool. \n",
    "        If the rat would not bump into the wall, then it simply returns newposition. The function \n",
    "        also returns the direction the rat will be headed.\n",
    "        \"\"\"\n",
    "\n",
    "        # determine if the newposition is outside the pool, if not, just return the new position\n",
    "        if (np.linalg.norm(newposition) < self.radius):\n",
    "            refposition  = newposition\n",
    "            refdirection = newposition - self.position[:,self.t]\n",
    "\n",
    "        else:\n",
    "\n",
    "            # determine where the rat will hit the pool wall\n",
    "            px = self.intercept(newposition)\n",
    "            \n",
    "            # get the tangent vector to this point by rotating -pi/2\n",
    "            tx = np.asarray(np.matmul([[0, 1], [-1, 0]],px))\n",
    "\n",
    "            # get the vector of the direction of movement\n",
    "            dx = px - self.position[:,self.t]\n",
    "            \n",
    "            # get the angle between the direction of movement and the tangent vector\n",
    "            theta = np.arccos(np.matmul((np.divide(tx,np.linalg.norm(tx))).transpose(),(np.divide(dx,np.linalg.norm(dx))))).item()\n",
    "\n",
    "            # rotate the remaining direction of movement vector by 2*(pi - theta) to get the reflected direction\n",
    "            ra = 2*(np.pi - theta)\n",
    "            refdirection = np.asarray(np.matmul([[np.cos(ra), -np.sin(ra)], [np.sin(ra), np.cos(ra)]],(newposition - px)))\n",
    "\n",
    "            # get the reflected position\n",
    "            refposition = px + refdirection\n",
    "\n",
    "        # make sure the new position is inside the pool\n",
    "        if (np.linalg.norm(refposition) > self.radius):\n",
    "            refposition = np.multiply((refposition/np.linalg.norm(refposition)),(self.radius - 1))\n",
    "\n",
    "        return [refposition, refdirection]\n",
    "    \n",
    "    ####################################################################\n",
    "    # for checking when/where the rat hits the edge of the pool\n",
    "    def intercept(self,newposition):\n",
    "        \n",
    "        \"\"\"\n",
    "        The intercept function returns the point in space at which the rat will intercept with the pool wall \n",
    "        if it is moving from point P1 to point P2 in space, given the pool radius.\n",
    "        \"\"\"\n",
    "        \n",
    "        # for easy referencing, set p1 and p2\n",
    "        p1 = self.position[:,self.t]\n",
    "        p2 = newposition\n",
    "\n",
    "        # calculate the terms used to find the point of intersection\n",
    "        dx = p2[0] - p1[0]\n",
    "        dy = p2[1] - p1[1]\n",
    "        dr = np.sqrt(np.power(dx,2) + np.power(dy,2))\n",
    "        D  = p1[0]*p2[1] - p2[0]*p1[1]\n",
    "        sy = np.sign(dy)\n",
    "        if (sy == 0):\n",
    "            sy = 1.0\n",
    "            \n",
    "        # calculate the potential points of intersection\n",
    "        pp1 = np.zeros((2,))\n",
    "        pp2 = np.zeros((2,))\n",
    "\n",
    "        pp1[0] = (D*dy + sy*dx*np.sqrt((np.power(self.radius,2))*(np.power(dr,2))-np.power(D,2)))/(np.power(dr,2))\n",
    "        pp2[0] = (D*dy - sy*dx*np.sqrt((np.power(self.radius,2))*(np.power(dr,2))-np.power(D,2)))/(np.power(dr,2))\n",
    "        pp1[1] = (-D*dx + np.absolute(dy)*np.sqrt((np.power(self.radius,2))*(np.power(dr,2))-np.power(D,2)))/(np.power(dr,2))\n",
    "        pp2[1] = (-D*dx - np.absolute(dy)*np.sqrt((np.power(self.radius,2))*(np.power(dr,2))-np.power(D,2)))/(np.power(dr,2))\n",
    "\n",
    "        # determine which intersection point is actually the right one (whichever is closer to p2)\n",
    "        if np.linalg.norm(p2 - pp1) < np.linalg.norm(p2 - pp2):\n",
    "            px = pp1\n",
    "\n",
    "        else:\n",
    "            px = pp2\n",
    "        \n",
    "        return px\n",
    "    \n",
    "    ####################################################################\n",
    "    # sets the start position of the rat in the pool\n",
    "    def startposition(self):\n",
    "\n",
    "        # select a random location from the main cardinal axes and calculate it's vector angle\n",
    "        condition = 2*np.random.randint(0,4)\n",
    "        angle = self.direction[condition]\n",
    "\n",
    "        self.position[:,0] = np.asarray([np.cos(angle), np.sin(angle)]) * (self.radius - 1)\n",
    "        \n",
    "    ####################################################################\n",
    "    # plot the most recent path of the rat through the pool\n",
    "    def plotpath(self):\n",
    "        \n",
    "        # create the figure \n",
    "        fig = plt.figure()\n",
    "        ax = fig.gca()\n",
    "\n",
    "        # create the pool perimeter\n",
    "        pool_perimeter = plt.Circle((0, 0), self.radius, fill=False, color='b', ls='-')\n",
    "        ax.add_artist(pool_perimeter)\n",
    "\n",
    "        # create theplatform\n",
    "        platform = plt.Circle(self.platform_location, self.platform_radius, fill=False, color='r', ls='-')\n",
    "        ax.add_artist(platform)\n",
    "\n",
    "        # plot the path\n",
    "        plt.plot(self.position[0,0:self.t],self.position[1,0:self.t], color='k', ls='-')\n",
    "\n",
    "        # plot the final location and starting location\n",
    "        plt.plot(self.position[0,0],self.position[1,0],color='b', marker='o',markersize=4, markerfacecolor='b')\n",
    "        plt.plot(self.position[0,self.t-1],self.position[1,self.t-1],color='r', marker='o',markersize=6, markerfacecolor='r')\n",
    "\n",
    "        # adjust the axis\n",
    "        ax.axis('equal')\n",
    "        ax.set_xlim((-self.radius-50, self.radius+50))\n",
    "        ax.set_ylim((-self.radius-50, self.radius+50))\n",
    "        plt.xticks(np.arange(-self.radius, self.radius+20, step=20))\n",
    "        plt.yticks(np.arange(-self.radius, self.radius+20, step=20))\n",
    "        ax.set_xlabel('X Position (cm)')\n",
    "        ax.set_ylabel('Y Position (cm)')\n",
    "\n",
    "        # turn on the grid\n",
    "        plt.grid(True)\n",
    "        plt.tight_layout()\n",
    "\n",
    "        # show the figure\n",
    "        plt.show()\n",
    "        \n",
    "    ####################################################################\n",
    "    # checks whether the time is up\n",
    "    def timeup(self):\n",
    "        \n",
    "        \"\"\"\n",
    "        Returns true if the time for the trial is finished, false otherwise.\n",
    "        \"\"\"\n",
    "        \n",
    "        return self.t > (self.T - 2)\n",
    "    \n",
    "    ####################################################################\n",
    "    # checks whether the rat has found the platform\n",
    "    def atgoal(self):\n",
    "        \n",
    "        \"\"\"\n",
    "        Returns true if the rat is on the platform, false otherwise.\n",
    "        \"\"\"\n",
    "        \n",
    "        return np.sqrt(np.sum((self.position[:,self.t] - self.platform_location)**2)) <= (self.platform_radius + 1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 81,
   "metadata": {},
   "outputs": [
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Clever rat, you found the platform in 8 seconds!\n"
     ]
    }
   ],
   "source": [
    "# demo of how to use the watermaze module\n",
    "\n",
    "# create the watermaze object\n",
    "maze = watermaze()\n",
    "\n",
    "# set the starting location\n",
    "maze.startposition()\n",
    "\n",
    "# run forward for one trial (using random actions for sake of illustration)\n",
    "while(not maze.timeup() and not maze.atgoal()):\n",
    "    \n",
    "    # select a random action - this is what your actor critic network needs to provide\n",
    "    A = np.random.randint(0,8)\n",
    "    \n",
    "    # move the rat\n",
    "    maze.move(A)\n",
    "    \n",
    "# plot the path\n",
    "maze.plotpath()\n",
    "\n",
    "# print out why the trial ended (note, if the rat reached the goal, then you must deliver a reward)\n",
    "if maze.atgoal():\n",
    "    print(\"Clever rat, you found the platform in\",maze.t,\"seconds!\")\n",
    "else:\n",
    "    print(\"No more time for you dumb-dumb...\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 82,
   "metadata": {},
   "outputs": [],
   "source": [
    "#helper functions to initialize the place cell center points in a circular manner \n",
    "#from https://stackoverflow.com/questions/33510979/generator-of-evenly-spaced-points-in-a-circle-in-python\n",
    "def circle_points(r, n): #r is array of radii, n is number of points per radius\n",
    "    circles = [] \n",
    "    for r, n in zip(r, n):\n",
    "        t = np.linspace(0, (2*math.pi), n)\n",
    "        x = r * np.cos(t)\n",
    "        y = r * np.sin(t)\n",
    "        circles.append(np.c_[x, y])\n",
    "    return circles\n",
    "\n",
    "def initialize_place_cells(): \n",
    "    #hard code in r and n to get the 493 place cells for this purpose\n",
    "    r = [0, 6, 12, 18, 24, 30, 36, 42, 48, 54, 60] #radii of concentric circles\n",
    "    n = [1,7, 15,20,25,35,50,60,80,90,110] # 493 place cells total; number of place cells per concentric circle\n",
    "    cells = np.array(circle_points(r, n))\n",
    "    stacked = np.vstack(cells)\n",
    "    return np.array(stacked)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 83,
   "metadata": {},
   "outputs": [],
   "source": [
    "class actor_critic(object):\n",
    "    def __init__(self, place_cells=initialize_place_cells(), critic_network=np.full(493,0.5), actor_network=np.zeros((493,8)), gamma=.98, alpha_A=.1,alpha_C=.01 ,sigma=16.0,platform_radius=10, platform_location=np.array([[25],[25]])): #gamma is the discount; alpha is the learning rate\n",
    "       \n",
    "        self.place_cells = place_cells #stores the value of the center of the placefield, initialized above ^\n",
    "        \n",
    "        self.W = critic_network.astype(float) #493x1 array btw 1 critic and 493 place cells\n",
    "        \n",
    "        self.Z = actor_network.astype(float) #network of weights btw actor and place cells (493,8)\n",
    "        \n",
    "        self.maze = watermaze()\n",
    "        \n",
    "        self.gamma = gamma #discount factor\n",
    "        self.alpha_A = alpha_A #learning rate for actor\n",
    "        self.alpha_C = alpha_C #learning rate for critic\n",
    "        self.sigma = sigma #radius of the place field\n",
    "    \n",
    "        self.platform_location = platform_location #same platform location as the mouse maze one; in multi-platform case you input the other platform as an argument to the funtion.\n",
    "       \n",
    "        self.platform_radius = platform_radius \n",
    "        \n",
    "    def get_position(self):\n",
    "        cur_t = self.maze.t\n",
    "        cur_x = self.maze.position[0][cur_t] #to convert the position to an [x,y] format that is more easily accessible\n",
    "        cur_y = self.maze.position[1][cur_t]\n",
    "        return (cur_x, cur_y)\n",
    "    \n",
    "    #Equation 1: the fi function. returns an (493,) array of the activities of all the cells\n",
    "    def place_activity(self):\n",
    "        cur_pos = self.get_position() #get the current position\n",
    "        pos_vec = np.array([cur_pos]*493) #get a vector to get all the activities at once\n",
    "        norms = np.linalg.norm(pos_vec-self.place_cells, axis=1) #take the norm along each row (each pair of points)\n",
    "        norms_sqr = np.square(norms).astype(float)\n",
    "        fi = np.exp(-norms_sqr/(2*self.sigma**2))\n",
    "        #scale the activity values to avoid overflow:\n",
    "        if abs(np.amax(fi))>=100:\n",
    "            fi = (100.0*fi)/abs(np.amax(fi))  \n",
    "        return np.array(fi).astype(float) #returns the activities of the place cells at the current position.\n",
    "        \n",
    "    \n",
    "    #the aj function. returns a 8,1 array of the activities of the actor cells at this current position.\n",
    "    def actor_activity(self):\n",
    "        a = ((self.Z).T).dot(self.place_activity())\n",
    "        if abs(np.amax(a))>=100:\n",
    "            a = (100.0*a)/abs(np.amax(a)) #again, limit size of activies to avoid overflow error\n",
    "        return a.astype(float)   \n",
    "    \n",
    "    #Equation 9. PMF of the distribution. stochastic probability of swimming in a direction\n",
    "    def ProbJ(self, actor_activity):\n",
    "        values = [0, 1, 2, 3, 4, 5, 6, 7]\n",
    "        prob_dist = np.exp(2.0*actor_activity)/np.sum(np.exp(2.0*actor_activity))\n",
    "        choice = np.random.choice(values, 1, p=prob_dist) #use random choice to sample from the discrete distribution w/the probabilities specified by eqn. 9\n",
    "        return choice[0]\n",
    "       \n",
    "    #Equation 2: C(p) function, at the current location.\n",
    "    def Critic_Value(self): \n",
    "        Cp = (self.W).dot(self.place_activity()) #sum of wifi\n",
    "        return Cp \n",
    "\n",
    "    #to see if the mouse has found the platform\n",
    "    def found_platform(self):\n",
    "        cur_pos = self.get_position()\n",
    "        x = cur_pos[0]\n",
    "        y = cur_pos[1]\n",
    "        coords = np.array([x, y])\n",
    "        return np.sqrt(np.sum((coords - self.platform_location)**2)) <= (self.platform_radius + 1)\n",
    "    \n",
    "    \n",
    "    #reward for the single platform case\n",
    "    def get_reward(self):\n",
    "        if self.found_platform(): \n",
    "            return 1.0\n",
    "        else:\n",
    "            return 0.0\n",
    "  \n",
    "    #calculates the derivative wrt weights of the loss function, mulitplied by the initial activities\n",
    "    #basically the right side of equation 8\n",
    "    def E2(self, Cp_curpos, Cp_nextpos, Rt, initial_activities):\n",
    "        deriv = (Rt+self.gamma*Cp_nextpos-Cp_curpos)*initial_activities #multiplies each entry in the activity matrix by this coefficient\n",
    "        return deriv #a 1,144 matrix\n",
    "    \n",
    "    #function to update self.W (between Critic and Place cells); 144,1 array\n",
    "    #updating W according to equation 8\n",
    "    def update_W(self, Cp_curpos, Cp_nextpos, Rt, initial_activities):\n",
    "        deriv = self.E2(Cp_curpos, Cp_nextpos, Rt, initial_activities) #calculate the gradient\n",
    "        updated = self.W+self.alpha_C*deriv #multiply the current \n",
    "        self.W = updated\n",
    "  \n",
    "    #update Actor-place weights, according to equation 9.\n",
    "    def update_Z(self,Cp_curpos, Cp_nextpos, Rt, initial_activities, move_index):        \n",
    "        delta = self.E2(Cp_curpos, Cp_nextpos, Rt, initial_activities) #calculate the gradient\n",
    "        delta = delta.flatten()\n",
    "        col = self.Z[:,move_index] \n",
    "        col = col+self.alpha_A*delta\n",
    "        self.Z[:,move_index] = col #only the column that corresponds to the index of the chosen actor cell gets updated; others stay the same\n",
    "        \n",
    "    #to reset the positions stored, set time to 0, and choose a new start location for the rat between epochs\n",
    "    def reset_trial(self, start_pos):\n",
    "        self.maze.position = np.zeros((2,self.maze.T))\n",
    "        self.maze.t = 0\n",
    "        condition = 2*start_pos\n",
    "        angle = self.maze.direction[condition]\n",
    "        self.maze.position[:,0] = np.asarray([np.cos(angle), np.sin(angle)]) * (self.maze.radius - 1)\n",
    "\n",
    "    #to train the model and update the weights\n",
    "    #num_epochs is # of epochs, multi_platform is True/False to choose if you want 2 platforms, plot_all is T/F to choose if you want all the path plots to be shown (since plotting each time can clutter the screen)\n",
    "    def train(self, num_epochs, multi_platform, plot_all): \n",
    "        self.maze.startposition()\n",
    "        epochs_arr = np.arange(1, num_epochs+1, 1)  #make arrays to store the time it took for each epoch\n",
    "        trial_lengths = np.zeros(num_epochs)\n",
    "        \n",
    "        for epoch in range(num_epochs):\n",
    "            print(\"Epoch: \", epoch)\n",
    "\n",
    "            \n",
    "            if(not multi_platform):\n",
    "                print(\"======Single-Platform RMW=====\")\n",
    "                \n",
    "            if(multi_platform and epoch%10==0): #switch the platform every 5 trials\n",
    "                print(\"======Multi-Platform DMP=====\")\n",
    "                #generate a random point to start the platform at\n",
    "                R= 45 #radius of the pool - a little bit so that it doesnt generate too close to the edge\n",
    "                r = R * math.sqrt(np.random.rand())\n",
    "                theta = np.random.rand()*2*math.pi\n",
    "                x = r*np.cos(theta)\n",
    "                y =  r*np.sin(theta)\n",
    "\n",
    "                self.maze.platform_location = np.array([x,y])\n",
    "                self.platform_location = np.array([x,y])\n",
    "            \n",
    "            \n",
    "            start_ind=np.random.randint(0, 4) #choose a new start index for each epoch and use it for reset_trial function\n",
    "            self.reset_trial(start_ind)\n",
    "            while((not self.maze.timeup())): \n",
    "                cur_pos = self.get_position() #starting position\n",
    "                init_pc_activities = self.place_activity() #initial place activity\n",
    "                cp_cur = self.Critic_Value() #critic value...\n",
    "        \n",
    "                init_actor_activities = self.actor_activity() #store the actor activity, used in the probability function (but probably not even necessary)\n",
    "        \n",
    "                R1 = self.get_reward() #reward at time t\n",
    "                \n",
    "                move_index = self.ProbJ(init_actor_activities) #best movement index according to the probability distribution fn.\n",
    "                self.maze.move(move_index)\n",
    "                new_pos = self.get_position() #position after move\n",
    "                new_activities = self.place_activity() #activity after move\n",
    "                cp_after = self.Critic_Value() #critic value after move\n",
    "                self.update_W(cp_cur, cp_after, R1, new_activities)\n",
    "                self.update_Z(cp_cur, cp_after, R1,new_activities, move_index)\n",
    "\n",
    "                #if its not multiplatform, check if it's reached the one and only platform and set the time accordingly\n",
    "                if(self.found_platform()):\n",
    "                    print(\"Reached goal!\") \n",
    "                    trial_lengths[epoch] = self.maze.t\n",
    "                    if(plot_all):\n",
    "                        self.maze.plotpath()\n",
    "                    break\n",
    "\n",
    "                #if it times out, print time's up and set the corresponding slot in the array to None (indicating it was unsuccessful)\n",
    "                if(self.maze.timeup()):\n",
    "                    print(\"Time's up.\")\n",
    "                    \n",
    "                    trial_lengths[epoch] = None\n",
    "                    if(plot_all):\n",
    "                        self.maze.plotpath()\n",
    "\n",
    "                    break\n",
    "       \n",
    "            print(\"===================================================\")\n",
    "\n",
    "        #plot the latency\n",
    "        plt.plot(epochs_arr,trial_lengths)\n",
    "        plt.xlabel('Epoch number')\n",
    "        plt.ylabel('Time steps')\n",
    "        if(multi_platform):\n",
    "            plt.title(\"Actor-Critic DMP Performance\")\n",
    "            plt.savefig('pt1_DMP.eps')\n",
    "        elif(not multi_platform):\n",
    "            plt.title(\"Actor-Critic RMW Performance\")\n",
    "            plt.savefig('pt1_RMW.eps')\n",
    "        plt.show()\n",
    "\n",
    "    \n",
    "        \n",
    "        \n",
    "    \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 86,
   "metadata": {
    "scrolled": true
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Epoch:  0\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  1\n",
      "======Single-Platform RMW=====\n",
      "Time's up.\n",
      "===================================================\n",
      "Epoch:  2\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  3\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  4\n",
      "======Single-Platform RMW=====\n",
      "Time's up.\n",
      "===================================================\n",
      "Epoch:  5\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  6\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  7\n",
      "======Single-Platform RMW=====\n",
      "Time's up.\n",
      "===================================================\n",
      "Epoch:  8\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  9\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  10\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  11\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  12\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  13\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  14\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  15\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  16\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  17\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  18\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  19\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  20\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  21\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  22\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  23\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  24\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  25\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  26\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  27\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  28\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n",
      "Epoch:  29\n",
      "======Single-Platform RMW=====\n",
      "Reached goal!\n",
      "===================================================\n"
     ]
    },
    {
     "data": {
      "image/png": "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\n",
      "text/plain": [
       "<Figure size 432x288 with 1 Axes>"
      ]
     },
     "metadata": {
      "needs_background": "light"
     },
     "output_type": "display_data"
    },
    {
     "data": {
      "text/plain": [
       "'\\nMulti-Platform:\\ninitialized to 50 epochs, multi-platform (changing every 10 epochs, not plotting each path (plot_all=False)\\n'"
      ]
     },
     "execution_count": 86,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "\"\"\"\n",
    "Finally, creating and training the model. Uncomment the act.train(...) one by one to run each case :) \n",
    "\"\"\"\n",
    "\n",
    "act = actor_critic()\n",
    "\n",
    "\"\"\"\n",
    "Single-Platform:\n",
    "Initialized to 50 epochs, single-platform (multi_platform=False), not plotting each path (plot_all=False).\n",
    "\"\"\"\n",
    "\n",
    "act.train(30, False,False)\n",
    "\n",
    "\n",
    "\"\"\"\n",
    "Multi-Platform:\n",
    "initialized to 50 epochs, multi-platform (changing every 10 epochs, not plotting each path (plot_all=False)\n",
    "\"\"\"\n",
    "#act.train(50, True, False)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
